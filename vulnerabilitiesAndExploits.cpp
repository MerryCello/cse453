/*******************************************************************
 * Class: CSE 435
 * Prof: Br. Wilson
 * Ponder: Vulnerabilities and Exploits
 * Teammates:
 *    Kevin Foniciello, Brian Aguilar, Paul Semadeni, Chris Van Kammen,
 *    Jared Aston
 *
 * Purpose:
 *    The purpose of this assignment is to gain a deeper understanding
 *    of the components of memory injection vulnerabilities and to
 *    understand what is required for an exploit to work.
 *
 * Description:
 *
 *******************************************************************/
#include <iostream>
#include <string>
#include <cstring>
#include <malloc.h>

void runAllTests();
bool arrayTests();
bool arcTests();
bool vtableTests();
bool stackTests();
bool heapTests();
bool intTests();
bool ansiTests();

using namespace std;

#define WORKING_TEST_STATEMENT "    Working example of the code:\n"
#define EXPLOITED_TEST_STATEMENT "    Exploited example of the code:\n"


int main() {
   runAllTests();
   return 0;
}

/*************************************
 * ARRAY VULNERABILITY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
int arrayVulnerability(int index) { // Index used to exploit the array
   // Array to be exploited
   int array[6] = {0,1,2,3,4,5};
   int secret = 2;
   // Index of array is reachable through an external input
   array[index];

   return array[index];
}


/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
bool arrayWorking() {
   cout << WORKING_TEST_STATEMENT;
   // setup
   int input = 4;
   int expected = 4;
   cout << "\tIndex: " << input << endl;
   cout << "\tExpected Output: " << expected << endl;
   int result = arrayVulnerability(input);
   cout << "\tActual Output: " << result << endl;
   // test
   // output results
   // verify
   return expected == result;
}


/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
bool arrayExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   // setup
   int input = 6;
   int expected = 2;
   cout << "\tIndex: " << input << endl;
   cout << "\tExpected Output: " << expected << endl;
   int result = arrayVulnerability(input);
   cout << "\tActual Output: " << result << endl;
   // test
   // output results
   // verify
   return expected == result;
}


/*****************************************************************************
* ARC INJECTION
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to overwrite the function pointer.
 * 3. After the memory is overwritten, the function pointer must be dereferenced.
 *************************************/
string safe() {
   return "Safe!";
}

string unsafe() {
   return "Hacked!";
}

string arcVulnerability(long reference) {
   long buffer[4];
   // Pointer function
   string (* pointerFunction)() = safe;

   buffer[4] = reference; // cin >> buffer[4]

   return pointerFunction();
}

/**************************************
 * WORKING
 * Write a function called arcWorking() that calls arcVulnerability() with non-malicious input. As with arrayWorking(), the expectation is that the vulnerability function will behave normally. Provide output from this function.
 *************************************/
bool arcWorking() {
   cout << WORKING_TEST_STATEMENT;
   long input = (long)safe;
   string actualResult = arcVulnerability(input);

   cout << "\tInput: " << input << endl;
   cout << "\tExpected: " << safe() << endl;
   cout << "\tActual: " << actualResult << endl;

   return actualResult == safe();
}

/**************************************
 * EXPLOIT
 * Write a function called arcExploit() that calls arcVulnerability(). As with the array index exploit, list all the requirements for exploiting ARC injection and make sure that your expoit function exhibits them all. Provide output from this function.
 *************************************/
bool arcExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   long input = (long)unsafe;
   string actualResult = arcVulnerability(input);

   cout << "\tInput: " << input << endl;
   cout << "\tExpected: " << unsafe() << endl;
   cout << "\tActual: " << actualResult << endl;

   return actualResult == unsafe();
}


/*****************************************************************************
 * V-TABLE SPRAYING
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input to overwrite parts of the VTable.
 * 4. After a virtual function pointer is overwritten, the virtual functionmust be called.
 * Code from reading: http://phrack.org/issues/56/8.html#article
 *************************************/
class Corroded {
private:
   char Buffer[32];
public:
   void SetBuffer(const char *String) {
      strcpy(Buffer, String);
   }
   virtual void PrintBuffer() {
      cout << Buffer << endl;
   }
};

class Vulnerable1: public Corroded {
public:
   void PrintBuffer() {
      cout << "\tVulnerabilityClass1: ";
      Corroded::PrintBuffer();
   }
};

class Vulnerable2:public Corroded {
public:
 void PrintBuffer() {
  cout << "\tVulnerabilityClass2: ";
  Corroded::PrintBuffer();
 }
};
/**************************************
 * WORKING
 * Write a function called vtableWorking() that instantiates a Vulnerability object and calls the vulnerable method. However, the method will behave normally because malicious input is not passed to the method. Provide output from this function.
 *************************************/
bool vtableWorking() {
   cout << WORKING_TEST_STATEMENT;
   Vulnerable1 weak;
   return false;
}

/**************************************
 * EXPLOIT
 * Write a function called vtableExploit() that demonstrates vtable spraying. In other words, it is not necessary to demonstrate vtable smashing, but rather just spraying. Provide output from this function.
 *************************************/
char *BufferOverflow(unsigned long BufferAddress, int NAddress, int VPTROffset) {
   char *Buffer;
   unsigned long *LongBuffer;
   unsigned long CCOffset;
   int i;

   Buffer = (char*)malloc(VPTROffset+4+1);

   CCOffset = (unsigned long)VPTROffset-1;

   for (i = 0; i < VPTROffset; i++)
      Buffer[i] = '\x90';
   LongBuffer=(unsigned long*)Buffer;
   for (i = 0; i < NAddress; i++)
      LongBuffer[i] = BufferAddress+CCOffset;

   LongBuffer = (unsigned long*)& Buffer[VPTROffset];
   *LongBuffer = BufferAddress;
   Buffer[CCOffset] = '\xCC';
   Buffer[VPTROffset+4] = '\x00';

   return Buffer;
}

bool vtableExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   Corroded *Object[2];

   Object[0] = new Vulnerable1;
   Object[1] = new Vulnerable2;
   Object[0]->SetBuffer(BufferOverflow((unsigned long)& (*Object[0]),4,32));
   Object[1]->SetBuffer("string2");
   Object[0]->PrintBuffer();
   Object[1]->PrintBuffer();
   return false;
}


/*****************************************************************************
 * STACK SMASHING
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. There must be a buffer (such as an array) on the stack.
 * 2. The buffer must be reachable from an external input.
 * 3. The mechanism to fill the buffer from the external input must not correctly check for the buffer size.
 * 4. The buffer must be overrun (extend beyond the intended limits of the array).
 *************************************/
long stackVulnerability(char * input) {
   long returnAddress = 123456;
   char text[2];
   for (int i = 0; input[i] != '\0'; i++) {
      text[i]  = input[i];
   }

   return returnAddress;
}

/**************************************
 * WORKING
 * Write a function called stackWorking() that calls stackVulnerability() with non-malicious input. Provide output from this function.
 *************************************/
bool stackWorking() {
   cout << WORKING_TEST_STATEMENT;
   char input = 'a';
   stackVulnerability((char*)input);
   return false;
}

/**************************************
 * EXPLOIT
 * Write a function called stackExploit() that calls the stackVulnerability() and exploits it. In other words, we will not be accepting user input here. Instead we will pass a value or a buffer to vulnerability() that will cause the vulnerability to be made manifest. Please look at the criteria for each exploitation in the reading. Make sure that all the criteria for the exploitation are met with the exception of the external input (which will be simulated from the passed parameters). Provide output from this function.
 *************************************/
bool stackExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   string input = "hi 45678";
   stackVulnerability((char *)input.c_str());
   return false;
}


/*****************************************************************************
 * HEAP SPRAYING
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must not correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 * 5. The first buffer must be overrun (extend beyond the intended limits of the array).
 *************************************/
void heapVulnerability(char * input) {
   char * buffer1 = new char[10];
   char * buffer2 = new char[10];

   assert(buffer1 < buffer2);

   for(int i = 0; input[i] != '\0'; i++)
   {
      buffer1[i] = input[i];
   }

   delete [] buffer2;
}

/**************************************
 * WORKING
 * Write a function called heapWorking() that calls heapVulnerability() with non-malicious input. Provide output from this function.
 *************************************/
bool heapWorking() {
   cout << "Enter a name of a file. (ex. 1234567891)";
   cout << "User entered 'ABCDEFGHIJ'";
   cout << 'This is the output of the first buffer:' << buffer1 << endl;
   heapVulnerability(ABCDEFGHIJ);

}

/**************************************
 * EXPLOIT
 * Write a function called heapExploit() that calls heapVulnerability() and demonstrates heap spraying. In other words, heapVulnerability() must be vulnerable to heap smashing but you will only be required to demonstrate heap spraying. Provide output from this function.
 *************************************/
bool heapExploit() {
   cout << "Enter a name of a file. (ex. 1234567891)";
   cout << "User entered 'MYBOYMMBETTERGETGREATIWONMMIIICANTWAITTO'";
   cout << 'This is the output of the first buffer:' << buffer1 << endl;
   heapVulnerability(MYBOYMMBETTERGETGREATIWONMMIIICANTWAITTO);

}


/*****************************************************************************
 * INTEGER OVERFLOW
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinelmust be reachable through external output.
 *************************************/
int intVulnerability(int itemNumber) {
   int prices[10] = {4,7,10,9,15,47,35,75,12,50};

   if ((itemNumber - 1) + prices < prices + 10) {
      cout << "\tThe price for item " << itemNumber << " is $" << prices[itemNumber - 1] << endl;
      return prices[itemNumber - 1];
   }
   else {
      cout << "\t***Invalid item, please enter in a valid item number.***\n";
      return -1;
   }
}

/**************************************
 * WORKING
 * Write a function called intWorking() that calls integerVulnerability() with non-malicious input. Provide output from this function.
 *************************************/
bool intWorking() {
   cout << WORKING_TEST_STATEMENT;
   // item found
   int value1 = 4;
   int itemSearchedFor = 9; // i.e., found
   cout << "\tEnter a item number to view its price (1-10):\n";
   cout << "\t\tUser inputted the number " << value1 << ".\n";
   int returnedItem = intVulnerability(value1);
   cout << "\tItem was " << (itemSearchedFor == returnedItem ? "found, as expected" : "not found") << ".\n\n";

   // item not found
   int value2 = 20;
   int notFoundErrorCode = -1; //i.e., not found
   cout << "\tEnter a item number to view its price (1-10):\n";
   cout << "\t\tUser inputted the number " << value2 << ".\n";
   int returnedValue = intVulnerability(value2);
   cout << "\tItem was " << (notFoundErrorCode != returnedValue ? "found" : "not found, as expected") << ".\n\n";

   return itemSearchedFor == returnedItem && notFoundErrorCode == returnedValue;
}

/**************************************
 * EXPLOIT
 * Write a function called intExploit() that calls intVulnerability(). This code should manipulate the vulnerable function to perform a way that was not intended by the author. Provide output from this function.
 *************************************/
bool intExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   int value = -1;
   int resultNotExpected = -1; // Don't know what we're getting back, but it shouldn't be this
   cout << "\tEnter a item number to view its price (1-10):\n";
   cout << "\t\tUser inputted the number " << value << ".\n";
   int returnedValue = intVulnerability(value);
   cout << "\tItem was "
        << (returnedValue != resultNotExpected ? "thought to be found, as expected" : "not found")
        << ".\n\n";

   return returnedValue != resultNotExpected;
}


/*****************************************************************************
 * ANSI-UNICODE CONVERSION
 ****************************************************************************/

/**************************************
 * VULNERABILITY
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the number of elements in the buffer.
 *************************************/
void ansiVulnerability(long size, const string message) {
   if (size != 7)
   {
      cout << "\tThe size of the buffer is " << size << endl;
      cout << '\t' << message << endl;
   }
   else {
      cout << "\tThe number of elements in the buffer is " << size << endl;
      cout << '\t' << message << endl;
   }

}

/**************************************
 * WORKING
 * Write a function called ansiWorking() that calls ansiVulnerability() with non-malicious input. Provide output from this function.
 *************************************/
bool ansiWorking() {
   cout << WORKING_TEST_STATEMENT;
   long encrypted[8] = {'43', '89', '57', '10', '25', '98', '31', '28'};
   string message = "You are safe";

   int size = sizeof(encrypted) / sizeof(encrypted[0]);

   // This is returning the number of elements in the buffer.
   ansiVulnerability(size, message);
   return false;
}

/**************************************
 * EXPLOIT
 * Write a function called ansiExploit() that calls ansiVulnerability(). This code should manipulate the vulnerable function to perform a way that was not intended by the author.
 *************************************/
bool ansiExploit() {
   cout << EXPLOITED_TEST_STATEMENT;
   long encrypted[8] = {'75', '11', '63', '70', '53', '79', '17', '20'};
   string message = "You've been hacked";

   // This is returning the size of the buffer
   ansiVulnerability(sizeof(encrypted), message);
   return false;
}


/*****************************************************************************
 * UNIT TESTS
 ****************************************************************************/
enum TestStatuses {
   TODO = 0,
   FAILED = 1,
   PASSED = 2
};

class Test {
public:
   string name;
   bool (*run)();
   TestStatuses status;

   Test() : run(NULL), status(TODO) {}
   Test(string name, bool (*run)()) : name(name), run(run), status(TODO) {}
};

void runAllTests() {
   cout << "\nRunning tests on \"pathsAreHomographs(string, string)\"...\n";
   // Insert tests to run bellow
   Test tests[] = {
      {
        Test("ARRAY VULNERABILITY tests",
             arrayTests)
      },
      {
        Test("ARC INJECTION tests",
             arcTests)
      },
      {
        Test("V-TABLE SPRAYING tests",
             vtableTests)
      },
      {
        Test("STACK SMASHING tests",
             stackTests)
      },
      {
        Test("HEAP SPRAYING tests",
             heapTests)
      },
      {
        Test("INTEGER OVERFLOW tests",
             intTests)
      },
      {
        Test("ANSI-UNICODE CONVERSION tests",
             ansiTests)
      }
   };
   int numberOfTests = sizeof(tests) / sizeof(tests[0]);

   int testsPassedCount = 0;
   for (int i = 0; i < numberOfTests; i++) {
      cout << "Running " << tests[i].name << "...\n";
      bool testPassed = tests[i].run();
      if (testPassed) {
         cout << "    ...PASSED\n\n";
         tests[i].status = PASSED;
         testsPassedCount++;
      } else {
         cout << "    ...FAILED\n\n";
         tests[i].status = FAILED;
      }
   }

   cout << "==========================================================================\n"
        << testsPassedCount << "/" << numberOfTests << " tests passed\n";
}


/**************************************
 * ARRAY VULNERABILITY Test
 *************************************/
bool arrayTests() {
   bool works = arrayWorking();
   bool wasExploited = arrayExploit();
   return works && wasExploited;
}


/**************************************
 * ARC Injection Test
 *************************************/
bool arcTests() {
   bool works = arcWorking();
   bool wasExploited = arcExploit();
   return works && wasExploited;
}


/**************************************
 * VTable Spraying Test
 *************************************/
bool vtableTests() {
   bool works = vtableWorking();
   bool wasExploited = vtableExploit();
   return works && wasExploited;
}


/**************************************
 * Stack Smashing Test
 *************************************/
bool stackTests() {
   bool works = stackWorking();
   bool wasExploited = stackExploit();
   return works && wasExploited;
}


/**************************************
 * Heap Spraying Test
 *************************************/
bool heapTests() {
   bool works = heapWorking();
   bool wasExploited = heapExploit();
   return works && wasExploited;
}


/**************************************
 * Integer Overflow Test
 *************************************/
bool intTests() {
   bool works = intWorking();
   bool wasExploited = intExploit();
   return works && wasExploited;
}


/**************************************
 * ANSI-Unicode Conversion Test
 *************************************/
bool ansiTests() {
   bool works = ansiWorking();
   bool wasExploited = ansiExploit();
   return works && wasExploited;
}
